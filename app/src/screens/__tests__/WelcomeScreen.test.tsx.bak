import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { Alert } from 'react-native';
import WelcomeScreen from '../WelcomeScreen';
import { useOnboardingStore } from '../../store/onboardingStore';
import { notificationService } from '../../services/notifications/notificationService';
import { locationService } from '../../services/locationService';
import { logger } from '../../utils/logger';
import { ThemeProvider } from '../../theme';

// Mock navigation
const mockReplace = jest.fn();
jest.mock('@react-navigation/native', () => ({
  useNavigation: () => ({
    replace: mockReplace,
  }),
}));

// Mock stores and services
jest.mock('../../store/onboardingStore');
jest.mock('../../services/notifications/notificationService');
jest.mock('../../services/locationService');
jest.mock('../../utils/logger');

// Mock Alert
jest.spyOn(Alert, 'alert');

// Helper to render with ThemeProvider
const renderWithTheme = (component: React.ReactElement) => {
  return render(<ThemeProvider>{component}</ThemeProvider>);
};

describe('WelcomeScreen', () => {
  const mockCompleteOnboarding = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    (useOnboardingStore as unknown as jest.Mock).mockReturnValue({
      completeOnboarding: mockCompleteOnboarding,
    });
  });

  describe('Step Navigation', () => {
    it('should render step 1 (Welcome) by default', () => {
      const { getByTestId, getByText } = renderWithTheme(<WelcomeScreen />);
      
      expect(getByTestId('welcome-step')).toBeTruthy();
      expect(getByText('Welcome to Migralog')).toBeTruthy();
    });

    it('should navigate to step 2 when Continue is pressed on step 1', () => {
      const { getByTestId, getByText } = render(<WelcomeScreen />);
      
      const continueButton = getByText('Continue');
      fireEvent.press(continueButton);
      
      expect(getByTestId('disclaimer-step')).toBeTruthy();
      expect(getByText('Medical Disclaimer')).toBeTruthy();
    });

    it('should show Back button on step 2 and higher', () => {
      const { getByText, queryByText } = render(<WelcomeScreen />);
      
      // Step 1 - no back button
      expect(queryByText('Back')).toBeNull();
      
      // Navigate to step 2
      fireEvent.press(getByText('Continue'));
      
      // Step 2 - back button should appear
      expect(getByText('Back')).toBeTruthy();
    });

    it('should navigate back to step 1 when Back is pressed on step 2', () => {
      const { getByText, getByTestId } = render(<WelcomeScreen />);
      
      // Navigate to step 2
      fireEvent.press(getByText('Continue'));
      expect(getByTestId('disclaimer-step')).toBeTruthy();
      
      // Go back
      fireEvent.press(getByText('Back'));
      expect(getByTestId('welcome-step')).toBeTruthy();
    });

    it('should navigate through all 4 steps sequentially', async () => {
      const { getByText, getByTestId } = render(<WelcomeScreen />);
      
      // Step 1
      expect(getByTestId('welcome-step')).toBeTruthy();
      fireEvent.press(getByText('Continue'));
      
      // Step 2
      expect(getByTestId('disclaimer-step')).toBeTruthy();
      fireEvent.press(getByText('Continue'));
      
      // Step 3 - mock notification permission
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
        canAskAgain: true,
      });
      
      await waitFor(() => {
        expect(getByTestId('notification-permissions-step')).toBeTruthy();
      });
      
      fireEvent.press(getByText('Continue'));
      
      // Step 4
      await waitFor(() => {
        expect(getByTestId('location-permissions-step')).toBeTruthy();
      });
    });
  });

  describe('Notification Permission Handling', () => {
    it('should request notification permission when continuing from step 3', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
        canAskAgain: true,
      });
      
      // Navigate to step 3
      fireEvent.press(getByText('Continue')); // Step 1 -> 2
      fireEvent.press(getByText('Continue')); // Step 2 -> 3
      
      await waitFor(() => {
        expect(getByText('Enable Notifications')).toBeTruthy();
      });
      
      // Request permission
      fireEvent.press(getByText('Continue'));
      
      await waitFor(() => {
        expect(notificationService.requestPermissions).toHaveBeenCalled();
        expect(logger.log).toHaveBeenCalledWith(
          '[WelcomeScreen] Requesting notification permissions on step 3'
        );
      });
    });

    it('should show error alert when notification permission request fails', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      const error = new Error('Permission denied');
      (notificationService.requestPermissions as jest.Mock).mockRejectedValue(error);
      
      // Navigate to step 3
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      
      await waitFor(() => {
        expect(getByText('Enable Notifications')).toBeTruthy();
      });
      
      // Trigger permission request
      fireEvent.press(getByText('Continue'));
      
      await waitFor(() => {
        expect(Alert.alert).toHaveBeenCalledWith(
          'Permission Error',
          'Unable to request notification permission. You can enable notifications later in Settings.',
          expect.any(Array)
        );
      });
    });

    it('should continue to step 4 even if notification permission is denied', async () => {
      const { getByText, getByTestId } = render(<WelcomeScreen />);
      
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: false,
        canAskAgain: true,
      });
      
      // Navigate to step 3 and continue
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      
      await waitFor(() => {
        fireEvent.press(getByText('Continue'));
      });
      
      // Should still reach step 4
      await waitFor(() => {
        expect(getByTestId('location-permissions-step')).toBeTruthy();
      });
    });
  });

  describe('Location Permission Handling', () => {
    it('should request location permission when finishing onboarding', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
      });
      (locationService.requestPermission as jest.Mock).mockResolvedValue(true);
      
      // Navigate to step 4
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      await waitFor(() => fireEvent.press(getByText('Continue')));
      
      await waitFor(() => {
        expect(getByText('Finish Setup')).toBeTruthy();
      });
      
      // Finish onboarding
      fireEvent.press(getByText('Finish Setup'));
      
      await waitFor(() => {
        expect(locationService.requestPermission).toHaveBeenCalled();
      });
    });

    it('should timeout location permission request after 3 seconds', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      // Mock a delayed location permission that never resolves
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
      });
      (locationService.requestPermission as jest.Mock).mockImplementation(
        () => new Promise(() => {}) // Never resolves
      );
      
      // Navigate to step 4
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      await waitFor(() => fireEvent.press(getByText('Continue')));
      
      await waitFor(() => {
        fireEvent.press(getByText('Finish Setup'));
      });
      
      // Should timeout and log warning
      await waitFor(() => {
        expect(logger.warn).toHaveBeenCalledWith(
          '[WelcomeScreen] Location permission request timed out (likely E2E test)'
        );
      }, { timeout: 4000 });
    });

    it('should complete onboarding even if location permission fails', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
      });
      (locationService.requestPermission as jest.Mock).mockRejectedValue(
        new Error('Location unavailable')
      );
      
      // Navigate to step 4 and finish
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      await waitFor(() => fireEvent.press(getByText('Continue')));
      
      await waitFor(() => {
        fireEvent.press(getByText('Finish Setup'));
      });
      
      // Should still complete onboarding
      await waitFor(() => {
        expect(mockCompleteOnboarding).toHaveBeenCalled();
        expect(mockReplace).toHaveBeenCalledWith('MainTabs');
      });
    });
  });

  describe('Onboarding Completion', () => {
    it('should complete onboarding and navigate to MainTabs', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
      });
      (locationService.requestPermission as jest.Mock).mockResolvedValue(true);
      
      // Navigate to step 4
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      await waitFor(() => fireEvent.press(getByText('Continue')));
      
      await waitFor(() => {
        fireEvent.press(getByText('Finish Setup'));
      });
      
      await waitFor(() => {
        expect(mockCompleteOnboarding).toHaveBeenCalled();
        expect(mockReplace).toHaveBeenCalledWith('MainTabs');
      });
    });

    it('should show error alert if onboarding completion fails but still navigate', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      const error = new Error('Storage error');
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
      });
      (locationService.requestPermission as jest.Mock).mockResolvedValue(true);
      mockCompleteOnboarding.mockRejectedValue(error);
      
      // Navigate to step 4 and finish
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      await waitFor(() => fireEvent.press(getByText('Continue')));
      
      await waitFor(() => {
        fireEvent.press(getByText('Finish Setup'));
      });
      
      await waitFor(() => {
        expect(Alert.alert).toHaveBeenCalledWith(
          'Setup Complete',
          'Onboarding completed with some issues. You can adjust permissions in Settings.',
          expect.any(Array)
        );
      });
    });
  });

  describe('Loading States', () => {
    it('should show "Requesting..." text while requesting notification permission', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      let resolvePermission: (value: any) => void;
      const permissionPromise = new Promise((resolve) => {
        resolvePermission = resolve;
      });
      (notificationService.requestPermissions as jest.Mock).mockReturnValue(permissionPromise);
      
      // Navigate to step 3
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      
      await waitFor(() => {
        fireEvent.press(getByText('Continue'));
      });
      
      // Should show loading text
      expect(getByText('Requesting...')).toBeTruthy();
      
      // Resolve permission
      resolvePermission!({ granted: true });
    });

    it('should show "Setting up..." text while completing onboarding', async () => {
      const { getByText } = render(<WelcomeScreen />);
      
      (notificationService.requestPermissions as jest.Mock).mockResolvedValue({
        granted: true,
      });
      
      let resolveLocation: (value: boolean) => void;
      const locationPromise = new Promise<boolean>((resolve) => {
        resolveLocation = resolve;
      });
      (locationService.requestPermission as jest.Mock).mockReturnValue(locationPromise);
      
      // Navigate to step 4
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      await waitFor(() => fireEvent.press(getByText('Continue')));
      
      await waitFor(() => {
        fireEvent.press(getByText('Finish Setup'));
      });
      
      // Should show loading text
      await waitFor(() => {
        expect(getByText('Setting up...')).toBeTruthy();
      });
      
      // Resolve
      resolveLocation!(true);
    });

    it('should disable buttons while requesting permissions', async () => {
      const { getByText, getByTestId } = render(<WelcomeScreen />);
      
      let resolvePermission: (value: any) => void;
      const permissionPromise = new Promise((resolve) => {
        resolvePermission = resolve;
      });
      (notificationService.requestPermissions as jest.Mock).mockReturnValue(permissionPromise);
      
      // Navigate to step 3
      fireEvent.press(getByText('Continue'));
      fireEvent.press(getByText('Continue'));
      
      await waitFor(() => {
        fireEvent.press(getByTestId('next-button'));
      });
      
      // Button should be disabled
      const button = getByTestId('next-button');
      expect(button.props.accessibilityState?.disabled).toBe(true);
      
      // Resolve
      resolvePermission!({ granted: true });
    });
  });

  describe('Accessibility', () => {
    it('should have proper accessibility labels on progress indicator', () => {
      const { getByLabelText } = render(<WelcomeScreen />);
      
      expect(getByLabelText('Step 1 of 4')).toBeTruthy();
    });

    it('should have accessibility labels on navigation buttons', () => {
      const { getByLabelText, getByText } = render(<WelcomeScreen />);
      
      expect(getByLabelText('Continue to next step')).toBeTruthy();
      
      // Navigate to step 2 to show back button
      fireEvent.press(getByText('Continue'));
      expect(getByLabelText('Go back to previous step')).toBeTruthy();
    });

    it('should have accessible app icon with label', () => {
      const { UNSAFE_getByProps } = render(<WelcomeScreen />);
      
      const icon = UNSAFE_getByProps({ accessibilityLabel: 'Migralog app icon' });
      expect(icon).toBeTruthy();
    });
  });
});
